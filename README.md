ğŸ“ Course: Design and Analysis of Algorithms
ğŸ“ Bonus Task â€” String Matching Algorithm
ğŸ‘¤ Student: Sherkenov Zhanassyl
ğŸ¯ Goal

Implement one classical string-matching algorithm from scratch in Java, test it on multiple inputs, analyze time and space complexity, and create a GitHub repository containing:

Source code

Sample input and output

1â€“2 page report

Explanation of algorithm design and behavior on different input sizes

For this assignment, the Rabinâ€“Karp algorithm using a Polynomial Rolling Hash was selected.

1. Test Data Summary

Three test cases of increasing size were used to evaluate correctness and performance.

Test Case	Text Length	Pattern	Pattern Length	Expected Matches
Short	11 ("abracadabra")	"abra"	4	[0, 7]
Medium	68	"quick"	5	[4, 52]
Long	~22,000	"abcdabcy"	8	1000 occurrences (one per repetition)

The long dataset was generated by repeating
"abcxabcdabxabcdabcdabcy" 1000 times, creating a realistic stress test.

2. Results
A. Correctness (Match Positions)
Test Case	Found Matches	Correct?
Short	[0, 7]	âœ” Yes
Medium	[4, 52]	âœ” Yes
Long	1000 matches	âœ” Yes

All matches were detected correctly; no false positives appeared due to the use of verification after hash matches.

B. Execution Time

Approximate execution times measured using System.nanoTime().

Test Case	Time (ms)	Observations
Short	0.2 ms	Negligible runtime
Medium	0.7 ms	Efficient even with non-trivial input
Long	14.4 ms	Linear-scale performance across 22k text
C. Hash Collisions
Property	Value
Base (B)	911,382,323
Modulus (MOD)	1,000,000,007
Collision Rate	Practically zero during all tests

All potential collisions were eliminated by verifying matching substrings with regionMatches().

3. Analysis
ğŸ” Algorithm Behavior

Rabinâ€“Karp efficiently computes rolling hashes using:

ğ»
(
ğ‘ 
)
=
(
ğ‘ 
[
0
]
ğµ
ğ‘š
âˆ’
1
+
ğ‘ 
[
1
]
ğµ
ğ‘š
âˆ’
2
+
â‹¯
+
ğ‘ 
[
ğ‘š
âˆ’
1
]
)
â€Š
m
o
d
â€Š
ğ‘€
ğ‘‚
ğ·
H(s)=(s[0]B
mâˆ’1
+s[1]B
mâˆ’2
+â‹¯+s[mâˆ’1])modMOD

A prefix-hash array allows substring hash retrieval in O(1).

Pattern matching is then reduced to cheap integer comparisons.

ğŸ“ˆ Time Complexity
Operation	Complexity
Build prefix hash	O(n)
Compute pattern hash	O(m)
Slide pattern window	O(n)
Verify collisions	Average O(1)
Total (average)	O(n + m)
Worst-case	O(nm) (only with massive collisions, extremely rare)
ğŸ’¾ Space Complexity
Data	Space
Prefix hash array	O(n)
Power array	O(n)
Auxiliary variables	O(1)
Total	O(n)
ğŸ§ª Observations During Testing

Performance remains almost perfectly linear even at 22k characters.

Increasing pattern size does not significantly affect runtime unless collision verification is triggered.

The long repeated-text dataset demonstrates perfect rolling-hash behavior.

4. Conclusions
Feature	Strengths	Weaknesses
Rabinâ€“Karp (Polynomial Rolling Hash)	Fast average runtime, simple implementation, excellent for multi-pattern matching, easy hash reuse	Worst-case O(nm) if collisions occur
Hash Verification Step	Guarantees correctness	Small overhead when real matches occur
Rolling Hash Mechanism	Allows O(1) substring hashing	Requires careful choice of modulus/base
